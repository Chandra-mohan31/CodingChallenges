
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int c=0, m = matrix.length, n=matrix[0].length;
        int left = 0, right = n-1;
        int top = 0, bottom = m-1;
        ArrayList<Integer> ans = new ArrayList<>();
        while(left<=right && top<=bottom){
            if(c%2==0){
                for(int i=left;i<=right;i++){
                    ans.add(matrix[top][i]);
                }
                top++;
                for(int i=top;i<=bottom;i++){
                    ans.add(matrix[i][right]);
                }
                right--;
                
                
            }else{
                for(int i=right;i>=left;i--){
                    ans.add(matrix[bottom][i]);
                    
                }
                bottom--;
                for(int i=bottom;i>=top;i--){
                    ans.add(matrix[i][left]);
                }
                left++;
            }
            c++;
        }
        return ans;
    }
}

// class Solution {
//     public List<Integer> spiralOrder(int[][] matrix) {
//         int m = matrix.length;
//         int n = matrix[0].length;
//         ArrayList<Integer> arr = new ArrayList<Integer>(matrix.length + matrix[0].length);
//                 ArrayList<Integer> arr1 = new ArrayList<Integer>(matrix.length + matrix[0].length);

        
//         if(m==1 && n==1){
//             arr1.add(matrix[0][0]);
//             return arr1;
//         }else if(m==1){
//             for(int i=0;i<n;i++){
//                 arr.add(matrix[0][i]);
//             }
//             return arr;
//         }
//         else if(n==1){
//             for(int i=0;i<m;i++){
//                 arr.add(matrix[i][0]);
//             }
//             return arr;
//         }
//         else{
//         for(int i=0;i<matrix[0].length;i++){
//             arr.add(matrix[0][i]);
//         }
//         for(int i=1;i<matrix.length-1;i++){
//             arr.add(matrix[i][n-1]);
//         }
//         for(int i=n-1;i>=0;i--){
//             arr.add(matrix[m-1][i]);
//         }
//         for(int i=matrix.length-2;i>0;i--){
//             arr.add(matrix[i][0]);
//         }
        
//         for(int i=1;i<m-1;i++){
//             if(i%2 != 0){
//             for(int j=1;j<n-1;j++){
//                 arr.add(matrix[i][j]);
//             }
//             }else{
//             for(int j=n-2;j>0;j--){
//                 arr.add(matrix[i][j]);
//             }
//             }
//         }
//         }
//         return arr;
//     }
// }

// // public class Solution {
// //     public List<Integer> spiralOrder(int[][] matrix) {
        
// //         List<Integer> res = new ArrayList<Integer>();
        
// //         if (matrix.length == 0) {
// //             return res;
// //         }
        
// //         int dir=0;
// //         int r=0,c = 0, layer=0;
// //         int m=matrix.length;
// //         int n=matrix[0].length;
        
// //             res.add(matrix[0][0]);
// //              for (int step=1; step<m*n; step++) {
       
// //                 switch (dir) {

// //                     case 0:

// //                         if (c == (n - layer - 1)) //reached last column? 
// //                         {
// //                             dir=1; //go down now
// //                             r++;
// //                         }
// //                         else {
// //                             c++;
// //                         }
// //                         break;

// //                     case 1: //down

// //                         if (r == (m -layer -1) ) //reached last row? 
// //                         {
// //                             dir=2; //go left now
// //                             c--;
// //                         }
// //                         else {
// //                             r++;
// //                         }
// //                         break;
            
// //                     case 2: //left

// //                         if (c == layer)  //first column of last row
// //                         {
// //                             dir=3; //go up now
// //                             r--;
// //                         }
// //                         else {
// //                             c--;
// //                         }
// //                         break;

// //                     case 3: // up

// //                         if (r == layer + 1 ) 
// //                         {
// //                             dir=0;
// //                             c++;
// //                             layer++;
// //                         }
// //                         else {
// //                             r--;
// //                         }
// //                         break;
// //                 }

// //             res.add(matrix[r][c]);
// //         }
// //     return res; 
// //     }
// // }

##########################################################
class Solution {
    public int strStr(String haystack, String needle) {

        int n = needle.length();
        int h = haystack.length();
        if (n == 0) return 0;
        if (n > h) return -1;

           for (int i = 0; i <= h-n; i++) {
            if (haystack.charAt(i) == needle.charAt(0)) {
                for(int j=0 ;j<n ;j++){
                    if(needle.charAt(j) != haystack.charAt(i+j)){
                        break;
                    }
                    if(j == n-1) return i;
                }
            }
        }
        return -1;
    }
}
********************************************
class Solution {
    public int strStr(String haystack, String needle) {
        int n = haystack.length();
        int m = needle.length();
        boolean flag = false;
        if(m==0){
            return 0;
        }
        if(m>n){
            return -1;
        }
        
        for(int i=0;i<n;i++){
            // if(haystack.charAt(i)==needle.charAt(i)){
            //     System.out.print(haystack.charAt(i));
            // }
            // System.out.println(haystack.charAt(i));
            if(haystack.charAt(i)==needle.charAt(0)){
                // System.out.println(haystack.charAt(i));
                for(int j=0;j<m;j++){
                    //compare needle chars with the i+1,i+2,etc of the remaining cars in haystack if occurs return i;
                    int k = i;
                    if(haystack.charAt(k)==needle.charAt(j)){
                        flag = true;
                        k = k+1;
                    }else{
                        flag = true;
                        k = k+1;
                    }
                    
                }
                if(flag){
                    return i;
                }
            }
        }
        return -1;
    }
}
************************************************************

lastIndexOf(),indexOf();
###############################
class Solution {
    public int searchInsert(int[] nums, int target) {
        int i = 0;
     for(i=0;i<nums.length;i++){
         if(nums[i]==target || nums[i]>target){
             
             return i;
         }
     }   
        return i;
    }
}
###################################
public int removeDuplicates(int[] nums) {
    if (nums.length == 0) return 0;
    int i = 0;
    for (int j = 1; j < nums.length; j++) {
        if (nums[j] != nums[i]) {
            i++;
            nums[i] = nums[j];
        }
    }
    return i + 1;
}
#######################

public class Main
{
	public static void main(String[] args) {
	    int n = 6;
	    for(int i=1;i<=n;i++){
	        for(int k=0;k<i;k++){
	            System.out.print(" ");
	        }
	        for(int j=i;j<=n;j++){
	            System.out.print(j+" ");
	        }
	        System.out.println();
	    }
	    for (int i = n-1; i >= 1; i--)
        {
          for (int j = 1; j <= i; j++)
            {
                System.out.print(" ");
            } 
          for (int j = i; j <= n; j++)
            {
                System.out.print(j+" ");
            }  
            System.out.println();
        }
	    
	    

	}
}

_____________________________
public class Main
{
	public static void main(String[] args) {
	    int n = 5;
	    int j=0;
	    int i=0;
	  for(i=0 ; i<=n ;i++){
		    for(j=n; j>i ; j--){
		        System.out.print(" ");
		    }
		    for(int k=0 ; k<i ; k++){
		        System.out.print(" *");
		    }
		    System.out.println();
		}
	}
}
____________________________________________________
public class Main
{
	public static void main(String[] args) {
	    int n = 6;
	    for(int i=1;i<=n;i++){
	        for(int k=0;k<i;k++){
	            System.out.print(" ");
	        }
	        for(int j=i;j<=n;j++){
	            System.out.print(j+" ");
	        }
	        System.out.println();
	    }
	    
	    

	}
}

_______________________________________________________________

public class Main
{
	public static void main(String[] args) {
	    int n = 6;
	    for(int i=1;i<=n;i++){
	        for(int k=0;k<i;k++){
	            System.out.print(" ");
	        }
	        for(int j=i;j<=n;j++){
	            System.out.print(j+" ");
	        }
	        System.out.println();
	    }
	    for(int i=1;i<=n;i++){
	        for(int j=n; j>i ; j--){
		        System.out.print(" ");
		    }
		    for(int k=1 ; k<=i ; k++){
		        System.out.print(" "+k);
		    }
		    System.out.println();
	    }
	    
	    

	}
}
______________________________________________________________
class Solution {
    public int[][] updateMatrix(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        int[][] dist = new int[m][n];
        for (int i=0; i<m; i++)
            Arrays.fill(dist[i], m*n + 1);
        for (int i=0; i<m; i++) {
            for (int j=0; j<n; j++) {
                if (mat[i][j] == 0) {
                    dist[i][j] = 0;
                }
                else {
                    if (i > 0)
                        dist[i][j] = Math.min(dist[i][j], 1 + dist[i-1][j]);
                    if (j > 0)
                        dist[i][j] = Math.min(dist[i][j], 1 + dist[i][j-1]);
                }
            }
        }
        for (int i=m-1; i>=0; i--) {
            for (int j=n-1; j>=0; j--) {
                if (mat[i][j] == 0) {
                    dist[i][j] = 0;
                }
                else {
                    if (i < m-1)
                        dist[i][j] = Math.min(dist[i][j], 1 + dist[i+1][j]);
                    if (j < n-1)
                        dist[i][j] = Math.min(dist[i][j], 1 + dist[i][j+1]);
                }
            }
        }
        return dist;
    }
}

#####################################################################

class Solution {
    
    public boolean isHappy(int n) {
        int sumdigits = 0;
        // System.out.println(n);
        while(n != 0)   
        {  
        
        int remainder = n % 10;  
        sumdigits = sumdigits + (int)Math.pow(remainder,2); 
        n = n/10;  
        }
        // System.out.println(sumdigits);
        if(sumdigits == 1){
            return true;
        }
        else{
           if(sumdigits == 4){
               return false;
           }else{
               return isHappy(sumdigits);
           }
            
            
        }
            
            
        
    }
}
##########################################################
class Solution {
    static void rotate90Clockwise(int mat[][],int N)
    {
        for (int i = 0; i < N / 2; i++) {
            for (int j = i; j < N - i - 1; j++) {
                int temp = mat[i][j];
                mat[i][j] = mat[N - 1 - j][i];
                mat[N - 1 - j][i] = mat[N - 1 - i][N - 1 - j];
                mat[N - 1 - i][N - 1 - j] = mat[j][N - 1 - i];
                mat[j][N - 1 - i] = temp;
            }
        }
    }
    static boolean compareMat(int[][] a,int[][] b){
         boolean flag = true;    
        int row1 = a.length;    
        int col1 = a[0].length;    
        int row2 = b.length;    
        int col2 = b[0].length;      
        if(row1 != row2 || col1 != col2){     
            return false;
        }    
        else {    
            for(int i = 0; i < row1; i++){    
                for(int j = 0; j < col1; j++){    
                  if(a[i][j] != b[i][j]){    
                      flag = false;    
                      break;    
                  }    
                }    
            }    
                
            if(flag)    
                return true;
            else    
                return false;
        }    
    } 
    
    public boolean findRotation(int[][] mat, int[][] target) {
        int i=4;
        while(i>0){
            if(compareMat(mat,target)){
                return true;
                
            }else{
                rotate90Clockwise(mat,mat.length);
                }
            
                i = i-1;
        }
        return false;
    }
}
**********************************************

class Solution {
    public int minCostClimbingStairs(int[] cost) {
        // The array's length should be 1 longer than the length of cost
        // This is because we can treat the "top floor" as a step to reach
        int minimumCost[] = new int[cost.length + 1];
        
        // Start iteration from step 2, since the minimum cost of reaching
        // step 0 and step 1 is 0
        for (int i = 2; i < minimumCost.length; i++) {
            int takeOneStep = minimumCost[i - 1] + cost[i - 1];
            // System.out.println(minimumCost[i - 1]);
            int takeTwoSteps = minimumCost[i - 2] + cost[i - 2];
            minimumCost[i] = Math.min(takeOneStep, takeTwoSteps);
        }
        
        // The final element in minimumCost refers to the top floor
        return minimumCost[minimumCost.length - 1];
    }
}
################################################
class Solution {
    static void swap(int[] arr, int i, int j)
    {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    
    static int partition(int[] arr, int low, int high)
    {

        
        int pivot = arr[high];

        
        int i = (low - 1);

        for(int j = low; j <= high - 1; j++)
        {

            
            if (arr[j] < pivot)
            {

                
                i++;
                swap(arr, i, j);
            }
        }
        swap(arr, i + 1, high);
        return (i + 1);
    }

   
    static int[] quickSort(int[] arr, int low, int high)
    {
        if (low < high)
        {

           
            int pi = partition(arr, low, high);

            // Separately sort elements before
            // partition and after partition
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
        return arr;
    }
    
    public int minPairSum(int[] nums) {
        int max_sum = 0;
        int n = nums.length;
        int l = 0;
        int k = nums.length - 1;
        int[] sorted_arr = quickSort(nums,0,nums.length - 1);
       
        int i = 0;
        while(i < n/2){
            if(nums[l]+nums[k] > max_sum){
                max_sum = nums[l]+nums[k];
            }
            l = l+1;
            k = k-1;
            i++;
        }
        
        return max_sum;
        
        
    }
}
###########################################################################
class Solution {
    public int countGoodSubstrings(String s) {
        int count = 0;
        for (int i = 0; i < s.length(); i++){
            for (int j = i+1; j <= s.length(); j++){
                // System.out.println(s.substring(i, j));
                String s1 = s.substring(i,j);
                boolean status = false;
                if(s1.length() == 3){
                    if(s1.charAt(0) != s1.charAt(1) && s1.charAt(1) != s1.charAt(2) && s1.charAt(0) != s1.charAt(2)){
                    status = true;
                }
                }
                
                
                if(status){
                    count++;
                }
            }
        }
          
        return count;
            
    }
}
#####################################################
class Solution {
    public boolean checkZeroOnes(String s) {
        int r_one=0, r_zero=0, i, j, l, l_zero=0,l_one=0;
        l = s.length();
        for(i=0;i<l;i++){
            if(s.charAt(i)=='1'){
                l_one=1;
                j=i+1;
                while(j<l && s.charAt(j) == '1'){
                    l_one++;
                    j++;
                }
                if(r_one<l_one)
                    r_one=l_one;
                i=j-1;
            }
                
            else if(s.charAt(i)=='0'){
                l_zero=1;
                j=i+1;
                while(j<l && s.charAt(j) == '0'){
                    l_zero++;
                    j++;
                }
                if(r_zero<l_zero)
                    r_zero=l_zero;
                i=j-1;
            }
            
            
        }
        
        if(r_one>r_zero)
            return true;
        return false;
    }
}
#############################################################


class Solution {
    public int[] countBits(int n) {
        int ans[] = new int[n+1];
        for(int i=0;i<=n;i++){
            int c_ones = 0;
            String val = Integer.toBinaryString(i);
            for(int j=0;j<val.length();j++){
                if(val.charAt(j) == '1'){
                    c_ones++;
                }
            }
            ans[i] = c_ones;
        }
        return ans;
    }
}
############################################
class Solution {
    public int maxSubArray(int[] a) {
     
        int size = a.length;
        int max_so_far = Integer.MIN_VALUE, max_ending_here = 0;
        for (int i = 0; i < size; i++)
        {
            max_ending_here = max_ending_here + a[i];
            // System.out.println(a[i]+"--"+max_ending_here);
            if (max_so_far < max_ending_here){
                max_so_far = max_ending_here;
            }
            
            if (max_ending_here < 0){
                max_ending_here = 0;
            }
        }
        return max_so_far;    
    }
}
#########################################
class Solution {
    public int maxProfit(int[] prices) {

        int s = 0;
        int e = 0;
        int max_profit = 0;
        while(e < prices.length){
            if(prices[e] > prices[s]){
                max_profit = Math.max(max_profit, prices[e] - prices[s]);
            }
                
            else{
                s = e;
            }
                
            e += 1;
        }
            
        return max_profit;
    }
}
#########################################
class Solution
{
    public int minOperation(int n)
    {
        int count = 0;
        while(n != 0){
        if(n % 2 == 0){
        n /=2;
        }else{
        n -= 1;
        }
        count++;
        }
        return count;
                
    }
}
##############################################################
class Solution{
    static void swap(int[] arr, int i, int j)
    {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
     
    
    static int partition(int[] arr, int low, int high)
    {
         
        // pivot
        int pivot = arr[high];
         
      
        int i = (low - 1);
     
        for(int j = low; j <= high - 1; j++)
        {
             
            // If current element is smaller
            // than the pivot
            if (arr[j] < pivot)
            {
                 
                
                i++;
                swap(arr, i, j);
            }
        }
        swap(arr, i + 1, high);
        return (i + 1);
    }
     
    
    static void quickSort(int[] arr, int low, int high)
    {
        if (low < high)
        {
             
          
            int pi = partition(arr, low, high);
     
           
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }

    static ArrayList<Integer> candyStore(int candies[],int N,int K){
        // code here
        ArrayList<Integer> arr = new ArrayList<Integer>();
        quickSort(candies,0,candies.length-1);
        // System.out.print(Arrays.toString(candies));
        int max = 0;
        int index = 0;
        for(int i=N-1;i>=index;i--){
            max = max + candies[i];
            index += K;
            // System.out.print(index);
        }
        // System.out.print(max);
        
        int min = 0;
        for (int i = 0; i < N; i++) {
            // Buy current candy
            min += candies[i];
 
            // And take k candies for free
            // from the last
            N = N - K;
        }
        
        arr.add(min);
        arr.add(max);
        // arr.add(0);
        
        
        return arr;
        
    }
}
###########################################################
class Solution {
    static int partition(long[] arr, int low, int high)
    {
         
        // pivot
        long pivot = arr[high];
         
       
        int i = (low - 1);
     
        for(int j = low; j <= high - 1; j++)
        {
             
           
            if (arr[j] < pivot)
            {
                 
               
                i++;
                swap(arr, i, j);
            }
        }
        swap(arr, i + 1, high);
        return (i + 1);
    }
     
   
    static long[] quickSort(long[] arr, int low, int high)
    {
        if (low < high)
        {
             
           
            int pi = partition(arr, low, high);
     
           
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
        return arr;
    }
    static void swap(long[] arr, int i, int j)
    {
        long temp;
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
       
    }


    public long minValue(long a[], long b[], long n) 
    {
        // Your code goes here
        // int min = 0;
        long minsum = 0;
        
        long[] arr1 = new long[a.length];
        long[] arr2 = new long[b.length];
        arr1 = quickSort(a,0,a.length-1);
        arr2 = quickSort(b,0,b.length-1);
        // arr2 = quickSort(b,b.length-1,0);
        
        
        for(int i=0;i<n;i++){
            minsum = minsum + arr1[i]*arr2[arr2.length-i-1];
        }
        return minsum;
        
        
    }
}
##############################################################
static int partition(long[] arr, int low, int high)
    {
         
        // pivot
        long pivot = arr[high];
         
       
        int i = (low - 1);
     
        for(int j = low; j <= high - 1; j++)
        {
             
           
            if (arr[j] < pivot)
            {
                 
               
                i++;
                swap(arr, i, j);
            }
        }
        swap(arr, i + 1, high);
        return (i + 1);
    }
     
   
    static long[] quickSort(long[] arr, int low, int high)
    {
        if (low < high)
        {
             
           
            int pi = partition(arr, low, high);
     
           
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
        return arr;
    }
    static void swap(long[] arr, int i, int j)
    {
        long temp;
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
       
    }


#######################################
class Solution{
    static String findLargest(int N, int S){
        // code here
        int x=9, j=0;
        String num = "";
        if(S==0 && N>1)
            return "-1";
        while(N>0 && S>=0 && x>=0){
            if(S>=x){
                num += Integer.toString(x);
                S -= x;   
                N--;
                j++;
            }
            else
                x--;
        }
        if(S!=0)
         num = "-1";
        return num;
    }
}
#####################################################
class Solution{
    static void swap(int[] arr, int i, int j)
    {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
     
    
    static int partition(int[] arr, int low, int high)
    {
         
        // pivot
        int pivot = arr[high];
         
      
        int i = (low - 1);
     
        for(int j = low; j <= high - 1; j++)
        {
             
            // If current element is smaller
            // than the pivot
            if (arr[j] < pivot)
            {
                 
                
                i++;
                swap(arr, i, j);
            }
        }
        swap(arr, i + 1, high);
        return (i + 1);
    }
     
    
    static void quickSort(int[] arr, int low, int high)
    {
        if (low < high)
        {
             
          
            int pi = partition(arr, low, high);
     
           
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }
    
    static int toyCount(int N, int K, int arr[])
    {
        int p_toys = 0;
        int n_toys = 0;
        // code here
        quickSort(arr,0,N-1);
        for(int i=0;i<arr.length;i++){
            p_toys = p_toys + arr[i];
            if(p_toys <= K){
                
                n_toys = n_toys + 1;
            }else{
                p_toys = p_toys - arr[i];
            }
        }
        
        // System.out.println(p_toys);
        return n_toys;
        
    }
}
################################################
class Solution
{
    static void swap(int[] arr,int[] end,int i, int j)
    {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
        int temp2 = end[i];
        end[i] = end[j];
        end[j] = temp2;
    }
     
    
    static int partition(int[] start, int[] end, int low, int high)
    {
         
        // pivot
        int pivot = end[high];
         
        
        int i = (low - 1);
     
        for(int j = low; j <= high - 1; j++)
        {
             
            
            if (end[j] < pivot)
            {
                 
                
                i++;
                swap(start, end, i, j);
            }
        }
        swap(start, end, i + 1, high);
        return (i + 1);
    }
     
   
    static void quickSort(int[] start, int[] end, int low, int high)
    {
        if (low < high)
        {
             
            
            int pi = partition(start, end, low, high);
     
            
            quickSort(start, end, low, pi - 1);
            quickSort(start, end, pi + 1, high);
        }
        // return arr;
    }
    
    public static int activitySelection(int start[], int end[], int n)
    {
        
        int max = 1;
        int arr1[] = new int[n];
        int arr2[] = new int[n];
        
       
        
        int i, j;
        
        quickSort(start,end,0,n-1);
       
      
        
        i = 0;
        
        for (j = 1; j < n; j++)
        {
             
             if (start[j] > end[i])
             {
                
                  max = max + 1;
                  i = j;
              }
         }
        return max;
        
    }
}
###########################################################
class Solution
{
    //Function to build a Heap from array.
    void buildHeap(int arr[], int n)
    {
        // Your code here
         int startIdx = (n / 2) - 1;
  
        // Perform reverse level order traversal
        // from last non-leaf node and heapify
        // each node
        for (int i = startIdx; i >= 0; i--) {
            heapify(arr, n, i);
        }
    }
 
    //Heapify function to maintain heap property.
    void heapify(int arr[], int n, int i)
    {
        // Your code here
        int largest = i; // Initialize largest as root
        int l = 2 * i + 1; // left = 2*i + 1
        int r = 2 * i + 2; // right = 2*i + 2

        // If left child is larger than root
        if (l < n && arr[l] > arr[largest])
            largest = l;

        // If right child is larger than largest so far
        if (r < n && arr[r] > arr[largest])
            largest = r;

        // If largest is not root
        if (largest != i) {
            int swap = arr[i];
            arr[i] = arr[largest];
            arr[largest] = swap;

            // Recursively heapify the affected sub-tree
            heapify(arr, n, largest);
        }
    }
    
    //Function to sort an array using Heap Sort.
    public void heapSort(int arr[], int n)
    {
        //code here
        

        // Build heap (rearrange array)
        for (int i = n / 2 - 1; i >= 0; i--)
            heapify(arr, n, i);

        // One by one extract an element from heap
        for (int i = n - 1; i > 0; i--) {
            // Move current root to end
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;

            // call max heapify on the reduced heap
            heapify(arr, i, 0);
        }
    }
 }
 
#################################################################
class Tree
{
    static int count = 0;
    
    int countLeaves(Node node) 
    {
         // Your code
         
         if(node.left == null && node.right == null){
             count = count + 1;
         }
         if(node.left != null && node.right != null){
             countLeaves(node.left);
             countLeaves(node.right);
         }else if(node.left == null && node.right != null){
             countLeaves(node.right);
         }else if(node.left != null && node.right == null){
             countLeaves(node.left);
         }
         
         
    
    return count;
    }
}
###########################################
class Solution
{
    //Function to convert a binary tree into its mirror tree.
    Node mirror(Node node)
    {
	// Your code here
	if(node == null){
	    return node;
	}
	Node left=mirror(node.left);
	Node right = mirror(node.right);
	node.left = right;
	node.right = left;
	return node;
	
    }
}
###########################################
class Tree
{
    //Function to return list containing elements of left view of binary tree.
    ArrayList<Integer> leftView(Node root)
    {
      // Your code here
      ArrayList<Integer> out = new ArrayList<Integer>();
      Node p = root;
      
      while(p != null){
          out.add(p.data);
          if(p.left != null){
            //   out.add(p.data);
              p = p.left;
          }else if(p.left == null && p.right != null){
              p = p.right;
            //   out.add(p.data);
          }else if(p.left == null && p.right == null){
            //   out.add(p.data);
              break;
          }else{
              break;
          }
          
      }
      return out;
      
    }
}
#############################################################################
class Solution
{
    
    //Function to find maximum of each subarray of size k.
    static ArrayList <Integer> max_of_subarrays(int arr[], int n, int k)
    {
        // Your code here
        ArrayList<Integer> out = new ArrayList<Integer>();
   
        int j, max;

        for (int i = 0; i <= n - k; i++) {

            max = arr[i];

            for (j = 1; j < k; j++) {
                if (arr[i + j] > max)
                    max = arr[i + j];
            }
            // System.out.print(max + " ");
            out.add(max);
        }
        return out;
    }
}
###################################################
class Solution
{
    
    //Function to find maximum of each subarray of size k.
    static ArrayList <Integer> max_of_subarrays(int arr[], int n, int k)
    {
        // Your code here
        ArrayList<Integer> out = new ArrayList<Integer>();
        int i = 0;
        int j;
        while(i<=arr.length-k){
            
            int max = 0;
            for(j=i;j<i+k;j++){
                // int new_a[] = new int[20];
                if(arr[j]>=max){
                    max = arr[j];
                    
                }
                
            //   out.add(max);         
            }
            // System.out.print(max);
            out.add(max);
            i = i+1;
        }
        return out;
    }
}
################################################
class Solution
{
//Function to find starting point where the truck can start to get through
//the complete circle without exhausting its petrol in between.
// Queue<Integer> a = new LinkedList<Integer>();
// Queue<Integer> b = new LinkedList<Integer>();
// int x,y;
int tour(int petrol[], int distance[]) {
int size = petrol.length;
int index = -1;
int i = 0;
int balance = 0;
boolean circleStarted = false;

while (i != index) {
if (circleStarted && index == -1) {
break;
}
if (index == -1)
index = i;

int first = petrol[i] + balance;
int second = distance[i];

if (first - second < 0) {
index = -1;
balance = 0;
} else {
balance = first - second;
}
i++;
if (i == size) {
i = 0;
circleStarted = true;
}
}
return index;
}
}
#############################################
class GfG
{
    int minEle = 10000;
    Stack<Integer> s = new Stack<Integer>();

    /*returns min element from stack*/
    int getMin()
    {
	// Your code here
// 	while(!s.isEmpty()){
// 	    if()
// 	}
    if(s.isEmpty()){
        return -1;
    }else{
        return minEle;
    }
    // for(int i=0;i<=s.size();i++){
    //     if(minEle < s.get(i)){
    //         minEle = s.get(i);
    //     }
    // }
    // return minEle;
    }
    
    /*returns poped element from stack*/
    int pop()
    {
    if(s.isEmpty()){
        return -1;
    }
	// Your code here	
	int x = s.pop();
	if(x == minEle){
	    minEle = 10000;
	    for(int i=0;i<s.size();i++){
	        if(minEle > s.get(i)){
	            minEle = s.get(i);
	        }
	    }
	}
	return x;
    }

    /*push element x into the stack*/
    void push(int x)
    {
	// Your code here
	if(x < minEle){
	    minEle = x;
	}
	
	s.push(x);
	
	
    }	
}
################################################################
class Queues
{
    Queue<Integer> q1 = new LinkedList<Integer>();
    Queue<Integer> q2 = new LinkedList<Integer>();
    
    //Function to push an element into stack using two queues.
    void push(int a)
    {
	    // Your code here	
	    q1.add(a);
    }
    
    //Function to pop an element from stack using two queues. 
    int pop()
    {
       int a;
	    // Your code here
	    if(q1.isEmpty()){
            return -1;
        }
	   // Your code here
	   while(true){
	       a = q1.remove();
	       if(q1.isEmpty()){
	           break;
	       }
	       q2.add(a);
	   }
	   
	   
	   
	   //System.out.println(y);
	   
	   while(!q2.isEmpty()){
	       int x = q2.remove();
	       q1.add(x);
	   }
	   
	   return a;
    }
	
}
_________________________________________________________

Hashmap in java:

	key value pairs;
	extends abstract map;
	a single key cant contain more than one value but any value can contain differen keys;
	int hash,
	k key,
	v value,
	Node,
	Next.
***************************************************************
class StackQueue
{
    Stack<Integer> s1 = new Stack<Integer>();
    Stack<Integer> s2 = new Stack<Integer>();

    //Function to push an element in queue by using 2 stacks.
    void Push(int x)
    {
	   // Your code here
	   s1.push(x);
	   
	   
    }
	
    
    //Function to pop an element from queue by using 2 stacks.
    int Pop()
    {
        if(s1.isEmpty()){
            return -1;
        }
	   // Your code here
	   while(!s1.isEmpty()){
	       int x = s1.pop();
	       s2.push(x);
	   }
	   
	   
	   int y = s2.pop();
	   
	   while(!s2.isEmpty()){
	       int x = s2.pop();
	       s1.push(x);
	   }
	   
	   return y;
    }
}______________
class Solution
{
    
    //Function to check if brackets are balanced or not.
    static boolean ispar(String x)
    {
        // add your code here
        Stack<Character> s = new Stack<Character>();
        for(int i=0;i<x.length();i++){
            char y = x.charAt(i);
            if (y == '(' || y == '[' || y == '{'){
                s.push(y);
            }
            if(s.isEmpty()){
                return false;
            }
            char popped;
            if(y == ')'){
                popped = s.pop();
                if(popped == '[' || popped == '{'){
                    return false;
                }
            }else if(y == '}'){
                popped = s.pop();
                if(popped == '(' || popped == '['){
                    return false;
                }
            }else if( y == ']'){
                popped = s.pop();
                if(popped == '{' || popped == '('){
                    return false;
                }
            }
            
        }
        return s.isEmpty();
        
    }
}
________________________________________________________
class Solution
{
    void deleteNode(Node del)
    {
         // Your code here
         Node t = del.next;
         del.data = t.data;
         del.next = t.next;
         t = null;
        //  Node p = del;
        //  if(p.next == null){
        //      Node t = p;
        //      p.next = null;
        //      p = t;
        //  }
        //  if(p.next != null && p.next.next != null){
        //      p.next = p.next.next;
             
        //  }
         
    }
}
________________________________________________
class Solution
{
    //Function to sort a linked list of 0s, 1s and 2s.
    static Node segregate(Node head)
    {
        // add your code here
        Node p = head;
        Node out = new Node(0);
        Node out_out = out;
        Node a = new Node(0);
        Node q = a;
        Node b = new Node(0);
        Node r = b;
        Node c = new Node(0);
        Node s = c;
        
        while(p != null){
            Node t = new Node(p.data);
            if(p.data == 0){
                q.next = t;
                q = q.next;
            }
            else if(p.data == 1){
                r.next = t;
                r = r.next;
            }else if(p.data == 2){
                s.next = t;
                s = s.next;
            }
            // q.next = t;
            // q = q.next;
            p = p.next;
        }
        
        q.next = (b.next!=null)
? (b.next) : (c.next);
        r.next = c.next;
        s.next = null;
        // Updated head
        head = a.next;
        return head;
        
        
    }
}
__________________________________________________________
class MyStack 
{
    StackNode top;
    
    //Function to push an integer into the stack.
    void push(int a) 
    {
        // Add your code here
        StackNode t = new StackNode(a);
        if(top == null){
            top = t;
            return;
        }
        t.next = top;
        top = t;
        
    }
    
    //Function to remove an item from top of the stack.
    int pop() 
    {
        // Add your code here
        int a = -1;
        if(top == null){
            return a;
        }
        // StackNode t = top;
        a = top.data;
        top = top.next;
        return a;
        
        
    }
}
_____________________________________________________
class MyQueue
{
    QueueNode front, rear;
    
    //Function to push an element into the queue.
	void push(int a)
	{
        // Your code here
    QueueNode temp = new QueueNode(a);
    if(rear == null){
        front = rear = temp;
        return;
    }
    rear.next = temp;
    rear = temp;
	}
	
    //Function to pop front element from the queue.
	int pop()
	{
	    int a = -1;
	    if (front == null)
            return a;
        // Your code here
        
        QueueNode temp = front;
        front = front.next;
        
        
        a = temp.data;
        if(front == null){
            rear = null;
            
        }
        
        return a;
        
	}
}

________________________________________________________________________
class Solution{
    //Function to add two numbers represented by linked list.
    static Node addTwoLists(Node first, Node second){
        // code here
        // return head of sum list
         Node L1 = new Node(0);
        Node l1 = L1;
        Node L2 = new Node(0);
        Node l2 = L2;
        Node Fin = new Node(0);
        Node fin = Fin;
        Node a = new Node(0);
        Node ans = a;
        int carr=0, sum=0;
        boolean x=true;
        Node p,q;
        p = first;
        q = second;
        while(p != null){
            Node temp = new Node(p.data);
            temp.next = l1.next;
            l1.next = temp;
            p = p.next;
        }
        while(q != null){
            Node temp = new Node(q.data);
            temp.next = l2.next;
            l2.next = temp;
            q = q.next;
        }
        // Add
        // return l1;
        while((l1 != null || l2 != null) && x){
            Node node = new Node(0);
            // node.data=0;
            sum=0;
            if(carr != 0)
                sum += carr;
            if(l1 != null && l2 != null){
                sum += l1.data+l2.data;
                if(sum>9){
                    carr = sum/10;
                    sum %= 10;
                }
                else
                    carr=0;
                node.data += sum;
                l1 = l1.next;
                l2 = l2.next;
            }
            else if(l1 == null && l2 != null){
                sum += l2.data;
                if(sum>9){
                    carr = sum/10;
                    sum %= 10;
                }
                else
                    carr=0;
                node.data = sum;
                l2 = l2.next;
            }
            else if(l2 == null && l1 != null){
                sum += l1.data;
                if(sum>9){
                    carr = sum/10;
                    sum %= 10;
                }
                else
                    carr=0;
                node.data = sum;
                l1 = l1.next;
            }
            else if(carr != 0){
                node.data = sum;
                ans.next = node;
                ans = ans.next;
                x=false;
            }
            ans.next = node;
            ans = ans.next;
        }
        if(carr != 0){
            Node node = new Node(0);
            node.data = carr;
            ans.next = node;
            ans = ans.next;
        }
        a=a.next.next;
        while(a != null){
            Node temp = new Node(a.data);
            temp.next = fin.next;
            fin.next = temp;
            a = a.next;
        }
        fin = Fin.next;
        return(fin);
    }
}
_______________________________________
class Solution {
    // Function to pairwise swap elements of a linked list.
    // It should returns head of the modified list
    public Node pairwiseSwap(Node head)
    {
        if (head == null || head.next == null) {
            return head;
        }
 
        // Initialize previous and current pointers
        Node prev = head;
        Node curr = head.next;
 
        head = curr; // Change head before proceeding
 
        // Traverse the list
        while (true) {
            Node next = curr.next;
            curr.next = prev; // Change next of current as previous node
 
            // If next NULL or next is the last node
            if (next == null || next.next == null) {
                prev.next = next;
                break;
            }
 
            // Change next of previous to next next
            prev.next = next.next;
 
            // Update previous and curr
            prev = next;
            curr = prev.next;
        }
        return head;
    }
}
________________________________________________________
class GfG
{
    //Function to find the data of nth node from the end of a linked list.
    int getNthFromLast(Node head, int n)
    {
    	// Your code here
    	int size = 0;
    	int val = 0;
    	Node p = head;
    	while(p != null){
    	    size = size + 1;
    	    p = p.next;
    	}
    	if(n>size){
    	    return -1;
    	}
    	int x = size - n;
    	
    	    
    	int y = 1;
    	Node q = head;
    	while(q != null && x>0){
    	    
    	    q = q.next;
    	    x = x-1;
    	    
    	}
    	return q.data;
    }
}

_______________________________
class Solution
{
    static void rmloo(Node loop,Node curr){
        Node ptr1 = null;
        Node ptr2 = null;
        ptr1 = curr;
        while(1 == 1){
            ptr2 = loop;
            while(ptr2.next != loop && ptr2.next != ptr1){
                ptr2 = ptr2.next;
            }
            if(ptr2.next == ptr1){
                break;
            }
            ptr1 = ptr1.next;
        }
        ptr2.next = null;
    }
    //Function to remove a loop in the linked list.
    public static void removeLoop(Node head){
        // code here
        // remove the loop without losing any nodes
        Node p = head;
        Node q = head;
        int size = 0;
        while(p != null && q != null && q.next != null){
            p = p.next;
            q = q.next.next;
            if(p == q){
                rmloo(p,head);
                
                break;
                
            }
        }
    }
}
_________________________________

class Intersect
{
    //Function to find intersection point in Y shaped Linked Lists.
	int intersectPoint(Node head1, Node head2)
	{
         // code here
        Node p,q;
        p = head1;
        q = head2;
        int l1=0,l2=0;
        while(p != null){
            p=p.next;
            l1++;
        }
        while(q != null){
            q=q.next;
            l2++;
        }
        p = head1;
        q = head2;
        int dif;
        if(l1>l2){
            dif = l1-l2;
            while(p != null && dif>0){
                p = p.next;
                dif--;
            }
        }
        else{
            dif = l2-l1;
            while(q != null && dif>0){
                q = q.next;
                dif--;
            }
        }
        while(p != null && q != null){
            if(p==q)
                return p.data;
            p = p.next;
            q = q.next;
        }
        return -1;
	}
}
___________________________________
class Intersect
{
    //Function to find intersection point in Y shaped Linked Lists.
	int intersectPoint(Node head1, Node head2)
	{
         Node p = head1;
         Node q = head2;
         while(p!=null && q != null){
            //  System.out.println(p.data);
             
            //  System.out.println(q.data);
            
            if(p.data == q.data){
                return p.data;
            }else{
                if(p.next != null){
                    p = p.next;
                }else{
                    p = head1;
                }
            }
            
            
            
             if(q.next != null){
                 q = q.next;
             }else{
                 q = head2;
             }
             
            //  q = q.next;
             
         }
         
         return -1;
	}
}

__________________________________
# Enter your code here. Read input from STDIN. Print output to STDOUT
t = input()
t = int(t)
while(t>0):
    input2 = input()
    count = 0
    n_d = 0
    no_repeat = True
    alp = input2.isalnum()
    l = len(input2)
    
    arr = list(input2)
    r = []
    for i in arr:
        if(i.isalpha()):
            count = count + 1
        if(i.isdigit()):
            n_d = n_d + 1
        if(i not in r):
            r.append(i)
        else:
            no_repeat = False
    if(count>=2 and n_d>=3 and alp and no_repeat and l==10):
        print("Valid")
    else:
        print("Invalid")
    t = t-1
    ______________________________________
class Solution {
    public int removeElement(int[] nums, int val) {
        int l = nums.length;
        
        
        for(int i=0;i<l;i++){
            if(nums[i] == val){
                for(int j=i;j<l-1;j++){
                    nums[j] = nums[j+1];
                }
                l--;
                i--;
            }
            
            
        }
        return l;
    }
}
______________________________________

class Solution{
    //Function to rotate a linked list.
    public Node rotate(Node head, int k) {
        // add code here
        Node p = head;
        Node q = new Node(0);
        Node l = q;
        Node x = new Node(0);
        Node y = x;
        Node out = new Node(0);
        while(k>0 && p != null){
            Node t = new Node(p.data);
            l.next = t;
            l = l.next;
            k = k-1;
            p = p.next;
        }
        while(p != null){
            Node m = new Node(p.data);
            y.next = m;
            y = y.next;
            p = p.next;
        }
        out = x;
        while(out.next != null){
            out = out.next;
        }
        out.next = q.next;
        
        return x.next;
        
    }
}
______________________________________

class Solution
{
    //Function to reverse a linked list.
    Node reverseList(Node head)
    {
        Node p = head;
        Node q = new Node(0);
        while(p != null){
            Node temp = new Node(p.data);
            temp.next = q.next;
            q.next = temp;
            p = p.next;
        }
        return q.next;
    }
}
_______________________________________________________________________________
class Solution
{
    int getMiddle(Node head)
    {
         Node p = head;
         int len = 0;
         while(p!=null){
             
             len = len+1;
             p = p.next;
         }
         int mid = len/2;
         p = head;
         while(mid>0 && p!=null){
             mid = mid-1;
             
             p = p.next;
             
             
         }
        
         return p.data;
    }
}
__________________________________________________________________

class Solution {
    // static int Findfrequency(int ele,int[] nums){
    //     int count = 0;
    //     for(int i=0;i<nums.length;i++){
    //         if(nums[i]==ele){
    //             count = count + 1;
    //         }
    //     }
    //     // System.out.print(count);
    //     return count;
    // }
    public int majorityElement(int[] nums) {
        // int mostrepeated = 0;
        // int rept_val = 0;
        // int frequency;
        // for(int i=0;i<nums.length;i++){
        //     if(Findfrequency(nums[i],nums)>mostrepeated){
        //         mostrepeated = Findfrequency(nums[i],nums);
        //         rept_val = nums[i];
        //     }
        // }
        // System.out.print(rept_val);
        // return rept_val;
        int index=0;
        int count = 0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==nums[index]){
                count++;
            }else{
                count--;
            }
            if(count<0){
                index = i;
                count = 1;
            }
        }
        return nums[index];
    }
}
_________________________________________________________

class Solution {
    static int Findfrequency(int ele,int[] nums){
        int count = 0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==ele){
                count = count + 1;
            }
        }
        // System.out.print(count);
        return count;
    }
    public int majorityElement(int[] nums) {
        int mostrepeated = 0;
        int rept_val = 0;
        int frequency;
        for(int i=0;i<nums.length;i++){
            if(Findfrequency(nums[i],nums)>mostrepeated){
                mostrepeated = Findfrequency(nums[i],nums);
                rept_val = nums[i];
            }
        }
        // System.out.print(rept_val);
        return rept_val;
    }
}
_________________________________________________________
class Solution {
    public int getDecimalValue(ListNode head) {
        String binaryString="";
        while(head != null){
            binaryString = binaryString + Integer.toString(head.val);
            head = head.next;
        }
        int decimal=Integer.parseInt(binaryString,2);  
        return decimal;
    }
} 
   static boolean hasCycle(SinglyLinkedListNode head) {
        // boolean out = false;
        // ArrayList<Integer>  = new ArrayList<String>();
        int size = 0;
        
        // SinglyLinkedList a = new SinglyLinkedList();
        // SinglyLinkedList b = head;
        while(head != null){
            if(size >1000){
                return true;
            }
            
            // if(head.data ){
                
            // }
            // System.out.println(head.data);
            head = head.next;
            size++;
        }
        
        return false;

    }
______________________________________
class Solution {
    // public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    //     ListNode a = new ListNode();
    //     ListNode ans = a;
    //     int carr=0, sum;
    //     while(l1 != null || l2 != null){
    //         ListNode node = new ListNode();
    //         // ans = ans.next;
    //         if(carr != 0)
    //             node.val += carr;
    //         sum = l1.val+l2.val;
    //         if(sum>9){
    //             carr = sum/10;
    //             sum %= 10;
    //         }
    //         node.val += sum;
    //         // System.out.println(sum+" "+carr+"  "+ node.val);
    //         l1 = l1.next;
    //         l2 = l2.next;
    //         ans.next = node;
    //         ans = ans.next;
    //         // System.out.println(ans.next.val);
    //     }
    //     a=a.next;
    //     return(a);
    // }
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode dummyHead = new ListNode(0);
    ListNode p = l1, q = l2, curr = dummyHead;
    int carry = 0;
    while (p != null || q != null) {
        int x = (p != null) ? p.val : 0;
        int y = (q != null) ? q.val : 0;
        int sum = carry + x + y;
        carry = sum / 10;
        curr.next = new ListNode(sum % 10);
        curr = curr.next;
        if (p != null) p = p.next;
        if (q != null) q = q.next;
    }
    if (carry > 0) {
        curr.next = new ListNode(carry);
    }
    return dummyHead.next;
}
}
_______________________________________________________________________
class Solution {
    public List<List<Integer>> generate(int numRows) {
        
        List<List<Integer>> pascal = new ArrayList<>();
        
        pascal.add(new ArrayList<>());
        pascal.get(0).add(1);
        
        
        for (int row = 1; row < numRows; row++)
        {
            for (int col = 0; col < row+1; col++)
            {
                int left = (col == 0)  ? 0 : pascal.get(row-1).get(col-1);
                int right = (col == row) ? 0: pascal.get(row-1).get(col);
                
                if (col ==0)
                    pascal.add(new ArrayList<>());
                
                pascal.get(row).add(left+right);
            }
           
        }
        
        return pascal;
    }
}
______________________________________________
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        arr = []
        for i in range(numRows):
            b=[]
            b.append(1)
            for j in range(1, i):
                b.append(arr[i-1][j-1]+arr[i-1][j])
            if i>0:
                b.append(1)
            arr.append(b)
        return arr
________________________________________________________________________
class Solution {
    boolean hasPathSum = false;
    public boolean hasPathSum(TreeNode root, int targetSum) {
        findPath(root, new int[1], targetSum);
        return hasPathSum;
    }
    
    public void findPath(TreeNode root, int[] sum, int targetSum) {
        if(root == null)
            return;
        sum[0]+=root.val;
        if(root.left == null && root.right == null) {
            if(sum[0] == targetSum)
                hasPathSum = true;
        }
        findPath(root.left, sum, targetSum);
        findPath(root.right, sum, targetSum);
        sum[0]-=root.val;
    }
}
______________________________________________
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null){
            return 0;
        }else if(root.right==null){
            return 1+minDepth(root.left);
        }else if(root.left == null){
            return 1+minDepth(root.right);
        }
        else{
            return 1+min(minDepth(root.left),minDepth(root.right));
        }
    }
    static int min(int a, int b){
        if(a<b)
            return a;
        else
            return b;
    }
}
_________________________________________________________
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null)
            return 0;
        else
            return 1+max(maxDepth(root.left), maxDepth(root.right));
    }
    static int max(int a, int b){
        if(a>b)
            return a;
        else
            return b;
    }
    public boolean isBalanced(TreeNode root) {
        if(root == null){
            return true;
        }
        else if(Math.abs(maxDepth(root.left)-maxDepth(root.right))>1){
            return false;
            
        }else{
            return isBalanced(root.right) && isBalanced(root.left);
        }
        
    }
   
    
}
_______________________________________________________________________________
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return createBST(nums, 0, nums.length-1);
    }
    
    private TreeNode createBST(int[] nums, int left, int right) {
        if(right < left) {
            return null;
        }
        int mid = (right + left)/2;
        TreeNode leftTree = createBST(nums, left, mid-1);
        TreeNode rightTree = createBST(nums, mid+1, right);
        TreeNode node = new TreeNode(nums[mid], leftTree, rightTree);
        return node;
    }
}
______________________________________________________________________
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null)
            return 0;
        else
            return 1+max(maxDepth(root.left), maxDepth(root.right));
    }
    static int max(int a, int b){
        if(a>b)
            return a;
        else
            return b;
    }
    
}
_____________________________________________________________________
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return(check(root, root));
    }
    static boolean check(TreeNode p, TreeNode q){
        if(p == null && q == null)
            return true;
        if((p == null && q !=null) || (p != null && q == null))
            return false;
        else if(p.val != q.val) 
            return false;
        return check(p.left, q.right) && check(p.right, q.left);
    }
}
------------------------------------------------------------
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
            
        if (p == null && q == null) return true;
        if ((p != null && q == null)||(p == null && q != null)) return false;
        else if(p.val != q.val) return false;
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
             
    }
}
--------------------------------------------------------------------------------
check the code;
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
//         boolean x = true;
//         if (p != null && q!=null) {
//             if(p.val != q.val){
//                 x = false;
//             }
//             else if((p==null || q==null) && (p!=null || q != null) ){
//                 x = false;
//             }
//             else{
//                 x = isSameTree(p.left,q.left);
//             }
//             // x = isSameTree(p.left,q.left);
//             // x = isSameTree(p.left,q.right);
            
//         }
//         return x;
        boolean x=true;
        if(p==null && q==null){
            x = true;
        }
        else if((p==null || q==null) && (p!=null || q != null) ){
            x = false;
        }
        else if(p.val != q.val){
            x = false;
        }
        else if (p != null && q != null) {
            x = isSameTree(p.left,q.left);
            
            x = isSameTree(p.right,q.right);
        }
        return x;
        
     
    }
}
____________________________________________________________________________________________________________________
public class Tree { 
    static class Node {    
    int value; 
        Node left, right; 
          
        Node(int value){ 
            this.value = value; 
            left = null; 
            right = null; 
        } 
    } 
       
    public void insert(Node node, int value) {
        if (value < node.value) { if (node.left != null) { insert(node.left, value); } else { System.out.println(" Inserted " + value + " to left of " + node.value); node.left = new Node(value); } } else if (value > node.value) {
          if (node.right != null) {
            insert(node.right, value);
          } else {
            System.out.println("  Inserted " + value + " to right of "
                + node.value);
            node.right = new Node(value);
          }
        }
      }
     public void traverseInOrder(Node node) {
        if (node != null) {
            traverseInOrder(node.left);
            System.out.print(" " + node.value);
            traverseInOrder(node.right);
        }
     }
     
     public static void main(String args[]) 
    { 
    Tree tree = new Tree();
                Node root = new Node(5);
                System.out.println("Binary Tree Example");
                System.out.println("Building tree with root value " + root.value);
                tree.insert(root, 2);
                tree.insert(root, 4);
                tree.insert(root, 8);
                tree.insert(root, 6);
                tree.insert(root, 7);
                tree.insert(root, 3);
                tree.insert(root, 9);
                System.out.println("Traversing tree in order");
                tree.traverseLevelOrder();
                
              }
}
  
____________________________________________________________________________________________________________
public class Solution {
    public int climbStairs(int n) {
        int memo[] = new int[n + 1];
        return climb_Stairs(0, n, memo);
    }
    public int climb_Stairs(int i, int n, int memo[]) {
        if (i > n) {
            return 0;
        }
        if (i == n) {
            return 1;
        }
        if (memo[i] > 0) {
            return memo[i];
        }
        memo[i] = climb_Stairs(i + 1, n, memo) + climb_Stairs(i + 2, n, memo);
        return memo[i];
    }
}
---------------------------------------------------------------
public class Solution {
    public int climbStairs(int n) {
        return climb_Stairs(0, n);
    }
    public int climb_Stairs(int i, int n) {
        if (i > n) {
            return 0;
        }
        if (i == n) {
            return 1;
        }
        return climb_Stairs(i + 1, n) + climb_Stairs(i + 2, n);
    }
}
################################################
class Solution {
    public int arrangeCoins(int n) {
        int rows_full = 0;
 
        int i = 1;
        while(i<=n){
            n = n - i;
            i++;
            rows_full++;
            
            
        }
        return rows_full;
    }
}
###########################################################
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode r = new ListNode();
        ListNode rev = r, p=head, q;
        while(p!=null){
            ListNode t = new ListNode();
            t.val=p.val;
            t.next = rev.next;
            rev.next = t;
            p = p.next;
        }
        rev = rev.next;
        while(rev!=null) {
            if(rev.val !=head.val)
                 return (false);
            head = head.next;
            rev = rev.next;
        }
        return (true);
    }
}
#################################################
// class Solution {
//     ListNode pleft;
//     public boolean isPalindrome(ListNode head) {
//         pleft = head;
//         boolean res= isPalindromeHelper(head);
//         return res;
//     }
    
//     public boolean isPalindromeHelper(ListNode right){
//         if(right==null){
//             return true;
//         }
        
//         boolean rres = isPalindromeHelper(right.next);
//         if(rres==false){
//             return false;
//         }else if(pleft.val != right.val){
//             return false;
//         }else{
//             pleft = pleft.next;
//             return true;
//         }
//     }
//  }


#####################################################
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    
        
        ListNode dummy = new ListNode();
        ListNode currentl1 = l1;
        ListNode currentl2 = l2;
        ListNode megedLinkedList = dummy;
        while(currentl1 != null || currentl2 != null){
            
            if(currentl1 == null ){
               megedLinkedList.next = currentl2;
                break;
            }
            
            if(currentl2 == null){
                megedLinkedList.next = currentl1;
                break;
            }
            
        
            if(currentl1.val  >  currentl2.val){
                megedLinkedList.next =  currentl2;
                currentl2 = currentl2.next;
            }else{
                megedLinkedList.next =  currentl1;
                currentl1 = currentl1.next;
            }
            
            megedLinkedList = megedLinkedList.next;
        }
        
      return dummy.next;
        
    }
}
###########################################################
def solve(s):
    
    t = ""
    t = t + s[0].capitalize()
    for i in range(1,len(s)):
        if(s[i-1]==" "):
            
            t = t + s[i].upper()
        else:
            t = t +s[i]
        
        
        
        
    
    return t
####################################
def merge_the_tools(string, k):
    # your code goes here
    s = []
    for i in range(0,len(string),k):
        s.append(string[i:k])
        k = k+k
    
    for i in s:
        o = ""
        for j in i:
            if j not in o:
                o = o+j
        print(o) 
        

if __name__ == '__main__':
    string, k = input(), int(input())
    merge_the_tools(string, k)
###################################################
perfect squares sum to a given num:
class Solution:
    def numSquares(self, n: int) -> int:
        no_perfect = 0
        squares = []
        for i in range(1,int(n**0.5)+1):
            squares.append(i**2)
        v = []
        
        def printAllSubsetsRec(arr, n, v, Sum):

            
            if (Sum == 0):
                return len(v)

            if (Sum < 0):
                return sys.maxsize

            
            if (n == 0):
                return sys.maxsize

            
            x = printAllSubsetsRec(arr, n - 1, v, Sum)

            
            v.append(arr[n - 1])
            y = printAllSubsetsRec(arr, n, v,
                                   Sum - arr[n - 1])
            v.pop(len(v) - 1)

            return min(x, y)

        
        def printAllSubsets(arr, n, Sum):

            v = []
            return printAllSubsetsRec(arr, n, v, Sum)

        
        arr = squares
        Sum = n
        m = len(arr)

        return printAllSubsets(arr, m, Sum)
        

######################

    def reverseWords(self, s: str) -> str:
        out = ""
        arr = s.split()
        rev_arr = arr[::-1]
        for i in rev_arr: 
            out += i+" "  
    
   
            
            
        return out[:len(out)-1]
##############################################
--> next permutation:
class Solution:
    def nextPermutation(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        #>right
        i = len(nums)-1
        while i-1>=0 and nums[i-1]>=nums[i]:
            i -=1
        #>left
        if i-1>=0:
            j = i
            while j<len(nums) and nums[j]>nums[i-1]:
                j +=1
            #swap the min-max number
            nums[i-1],nums[j-1] = nums[j-1],nums[i-1]
        m = i
        n = len(nums)-1
        while m < n:
            nums[m],nums[n] = nums[n],nums[m]
            m +=1
            n -=1
###########################################################
check this-->

if __name__ == '__main__':
    x = int(raw_input())
    y = int(raw_input())
    z = int(raw_input())
    n = int(raw_input())
    out = []
    for i in range(x+1):
        if(i<=y):
            for j in range(y+1):
                if(j<=z):
                    arr=[]
                    for k in range(z+1):
                        
                        if(i+j+k !=n):
                            out.append([i,j,k])
    print(out)
               
##################
crct ans-->

if __name__ == '__main__':
    x = int(raw_input())
    y = int(raw_input())
    z = int(raw_input())
    n = int(raw_input())
    out = []
    for i in range(x+1):
        for j in range(y+1):
                for k in range(z+1):
                        
                        if(i+j+k !=n):
                            out.append([i,j,k])
    print(out)
                            
                            
                
##############################
if __name__ == '__main__':
    stds = []
    mrks = []
    mrks_without_dup = []
    out_arr = []
    
    for _ in range(int(input())):
        name = input()
        score = float(input())
        stds.append([name,score])
    
    l = len(stds)
    for i in stds:
        mrks.append(i[1])
    mrks.sort()
    for i in mrks:
        if(i not in mrks_without_dup):
            mrks_without_dup.append(i)
    second_lowest = mrks_without_dup[1]
    
    for i in stds:
        if(i[1]==second_lowest):
            out_arr .append(i[0])
    out_arr.sort()
    for j in out_arr:
        print(j)
######################################
T = int(input())
while(T):
  a = input().split()
  n = int(a[0])
  k = int(a[1])
  sum_ken = 0
  sum_amar = 0
  b = input().split()
  c = input().split()
  
  b = [int(i) for i in b]
  c = [int(i) for i in c]
  b.sort()
  c.sort()
  for i in range(k,0,-1):
    sum_ken = sum_ken + b[i]
  for i in range(k,0,-1):
    sum_amar = sum_amar + c[i]
  if(sum_ken > sum_amar):
    print("WIN")
  else:
    print("LOSE")
  T = T -1
#############################################
if __name__ == '__main__':
    stds = []
    mrks = []
    mrks_without_dup = []
    out_arr = []
    
    for _ in range(int(input())):
        name = input()
        score = float(input())
        stds.append([name,score])
    
    l = len(stds)
    for i in stds:
        mrks.append(i[1])
    mrks.sort()
    for i in mrks:
        if(i not in mrks_without_dup):
            mrks_without_dup.append(i)
    second_lowest = mrks_without_dup[1]
    
    for i in stds:
        if(i[1]==second_lowest):
            out_arr .append(i[0])
    out_arr.sort()
    for j in out_arr:
        print(j)
    
#######################################################
#!/bin/python3

import math
import os
import random
import re
import sys

#
# Complete the 'climbingLeaderboard' function below.
#
# The function is expected to return an INTEGER_ARRAY.
# The function accepts following parameters:
#  1. INTEGER_ARRAY ranked
#  2. INTEGER_ARRAY player
#

def climbingLeaderboard(ranked, player):
    # Write your code here
    ans = []
    for i in player:
        ranked.append(i)
        res = []
        [res.append(x) for x in ranked if x not in res]
        res.sort(reverse=True)
        ans.append(res.index(i)+1)
    return ans
if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    ranked_count = int(input().strip())

    ranked = list(map(int, input().rstrip().split()))

    player_count = int(input().strip())

    player = list(map(int, input().rstrip().split()))

    result = climbingLeaderboard(ranked, player)

    fptr.write('\n'.join(map(str, result)))
    fptr.write('\n')

    fptr.close()

###################################
li1 = ['A','B','C','D']
li2 = ['B','C']
uncomman_elements = list(set(li1) - set(li2)) + list(set(li2) - set(li1))
print(uncomman_elements)
for i in uncomman_elements:
    out1 = 0
    out2 = 0
    for j in str(ord(i)):
        
        out1 = out1 + int(j)
    for k in str(out1):
        out2 = out2 + int(k)
    print(out1)
    print(out2)
    
###############################################
i1 = 3521
i2 = 2452
i3 = 1352

# l_th = 0
# l_h =0
# l_t = 0
# l_u = 0
# s_th = 9
# s_h = 9
# s_t = 9
# s_u = 9

# print(i1%10)
# print(int((i1/10)%10))
# print(int(i1/100)%10)
# print(int(i1/1000))



if (i1%10 >= i2%10) and (i1%10 >= i3%10):
   l_u = i1%10
elif (i2%10 >= i1%10) and (i2%10 >= i3%10):
   l_u = i2%10
else:
   l_u = i3%10
   
   
if (int((i1/10)%10) >= int((i2/10)%10)) and (int((i1/10)%10) >= int((i3/10)%10)):
   l_t = int((i1/10)%10)
elif (int((i2/10)%10) >= int((i1/10)%10)) and (int((i2/10)%10) >= int((i3/10)%10)):
   l_t = int((i2/10)%10)
else:
    l_t = int((i3/10)%10)
    
if (int((i1/10)%10) >= int((i2/10)%10)) and (int((i1/10)%10) >= int((i3/10)%10)):
   l_t = int((i1/10)%10)
elif (int((i2/10)%10) >= int((i1/10)%10)) and (int((i2/10)%10) >= int((i3/10)%10)):
   l_t = int((i2/10)%10)
else:
    l_t = int((i3/10)%10)
   


##############################################
# Enter your code here. Read input from STDIN. Print output to STDOUT\
arr=input().split()
n=int(arr[0])
m=int(arr[1])
# first half
for i in range(int(n/2)):
    for j in range(int(n/2)-i):
        print("---", end="")
    for k in range(1+i*2):
        print(".|.", end="")
    for j in range(int(n/2)-i):
        print("---", end="")
    print()
    
# welcome
for i in range(int((m-7)/2)):
    print("-", end="")
print("WELCOME", end="")
for i in range(int((m-7)/2)):
    print("-", end="")
print()

# second half
for i in range(int(n/2)-1, -1, -1):
    for j in range(int(n/2)-i):
        print("---", end="")
    for k in range(1+i*2):
        print(".|.", end="")
    for j in range(int(n/2)-i):
        print("---", end="")
    print()
##########################################################
def print_formatted(number):
    # your code goes here
    for i in range(1,number+1):
        decimal = i
        
        # print(decimal,end=" ")
        # print("  ",end="")
        # print(decimal,end=" ")
        # print()
        # Python program to convert decimal into other number systems
        

        
        binary = bin(decimal)
        octal = oct(decimal)
        hexa = hex(decimal)
         
        # s=""
        # while(i):
        #     s=s+str(int(i%2))
        #     i=int(i/2)
        # binary = (s[::-1])
        print(decimal,end="   ")
        print(str(octal[2:]),end="   ")
        print(str(hexa[2:]).upper(),end = "   ")
        print(str(binary[2:]),end="   ")
        print()
        

if __name__ == '__main__':
    n = int(input())
    print_formatted(n)
###########################################################
def print_formatted(number):
    # your code goes here
    w = len(str(bin(number)).replace('0b',''))

    for i in range(1, number+1):
        b = bin(int(i)).replace('0b','').rjust(w, ' ')
        o = oct(int(i)).replace('0o','', 1).rjust(w, ' ')
        h = hex(int(i)).replace('0x','').upper().rjust(w, ' ')
        j = str(i).rjust(w, ' ')
        print(j, o, h, b)
    
        

if __name__ == '__main__':
#############################################################