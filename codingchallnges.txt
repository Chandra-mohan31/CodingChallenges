class Solution
{
    void deleteNode(Node del)
    {
         // Your code here
         Node t = del.next;
         del.data = t.data;
         del.next = t.next;
         t = null;
        //  Node p = del;
        //  if(p.next == null){
        //      Node t = p;
        //      p.next = null;
        //      p = t;
        //  }
        //  if(p.next != null && p.next.next != null){
        //      p.next = p.next.next;
             
        //  }
         
    }
}
________________________________________________
class Solution
{
    //Function to sort a linked list of 0s, 1s and 2s.
    static Node segregate(Node head)
    {
        // add your code here
        Node p = head;
        Node out = new Node(0);
        Node out_out = out;
        Node a = new Node(0);
        Node q = a;
        Node b = new Node(0);
        Node r = b;
        Node c = new Node(0);
        Node s = c;
        
        while(p != null){
            Node t = new Node(p.data);
            if(p.data == 0){
                q.next = t;
                q = q.next;
            }
            else if(p.data == 1){
                r.next = t;
                r = r.next;
            }else if(p.data == 2){
                s.next = t;
                s = s.next;
            }
            // q.next = t;
            // q = q.next;
            p = p.next;
        }
        
        q.next = (b.next!=null)
? (b.next) : (c.next);
        r.next = c.next;
        s.next = null;
        // Updated head
        head = a.next;
        return head;
        
        
    }
}
__________________________________________________________
class MyStack 
{
    StackNode top;
    
    //Function to push an integer into the stack.
    void push(int a) 
    {
        // Add your code here
        StackNode t = new StackNode(a);
        if(top == null){
            top = t;
            return;
        }
        t.next = top;
        top = t;
        
    }
    
    //Function to remove an item from top of the stack.
    int pop() 
    {
        // Add your code here
        int a = -1;
        if(top == null){
            return a;
        }
        // StackNode t = top;
        a = top.data;
        top = top.next;
        return a;
        
        
    }
}
_____________________________________________________
class MyQueue
{
    QueueNode front, rear;
    
    //Function to push an element into the queue.
	void push(int a)
	{
        // Your code here
    QueueNode temp = new QueueNode(a);
    if(rear == null){
        front = rear = temp;
        return;
    }
    rear.next = temp;
    rear = temp;
	}
	
    //Function to pop front element from the queue.
	int pop()
	{
	    int a = -1;
	    if (front == null)
            return a;
        // Your code here
        
        QueueNode temp = front;
        front = front.next;
        
        
        a = temp.data;
        if(front == null){
            rear = null;
            
        }
        
        return a;
        
	}
}

________________________________________________________________________
class Solution{
    //Function to add two numbers represented by linked list.
    static Node addTwoLists(Node first, Node second){
        // code here
        // return head of sum list
         Node L1 = new Node(0);
        Node l1 = L1;
        Node L2 = new Node(0);
        Node l2 = L2;
        Node Fin = new Node(0);
        Node fin = Fin;
        Node a = new Node(0);
        Node ans = a;
        int carr=0, sum=0;
        boolean x=true;
        Node p,q;
        p = first;
        q = second;
        while(p != null){
            Node temp = new Node(p.data);
            temp.next = l1.next;
            l1.next = temp;
            p = p.next;
        }
        while(q != null){
            Node temp = new Node(q.data);
            temp.next = l2.next;
            l2.next = temp;
            q = q.next;
        }
        // Add
        // return l1;
        while((l1 != null || l2 != null) && x){
            Node node = new Node(0);
            // node.data=0;
            sum=0;
            if(carr != 0)
                sum += carr;
            if(l1 != null && l2 != null){
                sum += l1.data+l2.data;
                if(sum>9){
                    carr = sum/10;
                    sum %= 10;
                }
                else
                    carr=0;
                node.data += sum;
                l1 = l1.next;
                l2 = l2.next;
            }
            else if(l1 == null && l2 != null){
                sum += l2.data;
                if(sum>9){
                    carr = sum/10;
                    sum %= 10;
                }
                else
                    carr=0;
                node.data = sum;
                l2 = l2.next;
            }
            else if(l2 == null && l1 != null){
                sum += l1.data;
                if(sum>9){
                    carr = sum/10;
                    sum %= 10;
                }
                else
                    carr=0;
                node.data = sum;
                l1 = l1.next;
            }
            else if(carr != 0){
                node.data = sum;
                ans.next = node;
                ans = ans.next;
                x=false;
            }
            ans.next = node;
            ans = ans.next;
        }
        if(carr != 0){
            Node node = new Node(0);
            node.data = carr;
            ans.next = node;
            ans = ans.next;
        }
        a=a.next.next;
        while(a != null){
            Node temp = new Node(a.data);
            temp.next = fin.next;
            fin.next = temp;
            a = a.next;
        }
        fin = Fin.next;
        return(fin);
    }
}
_______________________________________
class Solution {
    // Function to pairwise swap elements of a linked list.
    // It should returns head of the modified list
    public Node pairwiseSwap(Node head)
    {
        if (head == null || head.next == null) {
            return head;
        }
 
        // Initialize previous and current pointers
        Node prev = head;
        Node curr = head.next;
 
        head = curr; // Change head before proceeding
 
        // Traverse the list
        while (true) {
            Node next = curr.next;
            curr.next = prev; // Change next of current as previous node
 
            // If next NULL or next is the last node
            if (next == null || next.next == null) {
                prev.next = next;
                break;
            }
 
            // Change next of previous to next next
            prev.next = next.next;
 
            // Update previous and curr
            prev = next;
            curr = prev.next;
        }
        return head;
    }
}
________________________________________________________
class GfG
{
    //Function to find the data of nth node from the end of a linked list.
    int getNthFromLast(Node head, int n)
    {
    	// Your code here
    	int size = 0;
    	int val = 0;
    	Node p = head;
    	while(p != null){
    	    size = size + 1;
    	    p = p.next;
    	}
    	if(n>size){
    	    return -1;
    	}
    	int x = size - n;
    	
    	    
    	int y = 1;
    	Node q = head;
    	while(q != null && x>0){
    	    
    	    q = q.next;
    	    x = x-1;
    	    
    	}
    	return q.data;
    }
}

_______________________________
class Solution
{
    static void rmloo(Node loop,Node curr){
        Node ptr1 = null;
        Node ptr2 = null;
        ptr1 = curr;
        while(1 == 1){
            ptr2 = loop;
            while(ptr2.next != loop && ptr2.next != ptr1){
                ptr2 = ptr2.next;
            }
            if(ptr2.next == ptr1){
                break;
            }
            ptr1 = ptr1.next;
        }
        ptr2.next = null;
    }
    //Function to remove a loop in the linked list.
    public static void removeLoop(Node head){
        // code here
        // remove the loop without losing any nodes
        Node p = head;
        Node q = head;
        int size = 0;
        while(p != null && q != null && q.next != null){
            p = p.next;
            q = q.next.next;
            if(p == q){
                rmloo(p,head);
                
                break;
                
            }
        }
    }
}
_________________________________

class Intersect
{
    //Function to find intersection point in Y shaped Linked Lists.
	int intersectPoint(Node head1, Node head2)
	{
         // code here
        Node p,q;
        p = head1;
        q = head2;
        int l1=0,l2=0;
        while(p != null){
            p=p.next;
            l1++;
        }
        while(q != null){
            q=q.next;
            l2++;
        }
        p = head1;
        q = head2;
        int dif;
        if(l1>l2){
            dif = l1-l2;
            while(p != null && dif>0){
                p = p.next;
                dif--;
            }
        }
        else{
            dif = l2-l1;
            while(q != null && dif>0){
                q = q.next;
                dif--;
            }
        }
        while(p != null && q != null){
            if(p==q)
                return p.data;
            p = p.next;
            q = q.next;
        }
        return -1;
	}
}
___________________________________
class Intersect
{
    //Function to find intersection point in Y shaped Linked Lists.
	int intersectPoint(Node head1, Node head2)
	{
         Node p = head1;
         Node q = head2;
         while(p!=null && q != null){
            //  System.out.println(p.data);
             
            //  System.out.println(q.data);
            
            if(p.data == q.data){
                return p.data;
            }else{
                if(p.next != null){
                    p = p.next;
                }else{
                    p = head1;
                }
            }
            
            
            
             if(q.next != null){
                 q = q.next;
             }else{
                 q = head2;
             }
             
            //  q = q.next;
             
         }
         
         return -1;
	}
}

__________________________________
# Enter your code here. Read input from STDIN. Print output to STDOUT
t = input()
t = int(t)
while(t>0):
    input2 = input()
    count = 0
    n_d = 0
    no_repeat = True
    alp = input2.isalnum()
    l = len(input2)
    
    arr = list(input2)
    r = []
    for i in arr:
        if(i.isalpha()):
            count = count + 1
        if(i.isdigit()):
            n_d = n_d + 1
        if(i not in r):
            r.append(i)
        else:
            no_repeat = False
    if(count>=2 and n_d>=3 and alp and no_repeat and l==10):
        print("Valid")
    else:
        print("Invalid")
    t = t-1
    ______________________________________
class Solution {
    public int removeElement(int[] nums, int val) {
        int l = nums.length;
        
        
        for(int i=0;i<l;i++){
            if(nums[i] == val){
                for(int j=i;j<l-1;j++){
                    nums[j] = nums[j+1];
                }
                l--;
                i--;
            }
            
            
        }
        return l;
    }
}
______________________________________

class Solution{
    //Function to rotate a linked list.
    public Node rotate(Node head, int k) {
        // add code here
        Node p = head;
        Node q = new Node(0);
        Node l = q;
        Node x = new Node(0);
        Node y = x;
        Node out = new Node(0);
        while(k>0 && p != null){
            Node t = new Node(p.data);
            l.next = t;
            l = l.next;
            k = k-1;
            p = p.next;
        }
        while(p != null){
            Node m = new Node(p.data);
            y.next = m;
            y = y.next;
            p = p.next;
        }
        out = x;
        while(out.next != null){
            out = out.next;
        }
        out.next = q.next;
        
        return x.next;
        
    }
}
______________________________________

class Solution
{
    //Function to reverse a linked list.
    Node reverseList(Node head)
    {
        Node p = head;
        Node q = new Node(0);
        while(p != null){
            Node temp = new Node(p.data);
            temp.next = q.next;
            q.next = temp;
            p = p.next;
        }
        return q.next;
    }
}
_______________________________________________________________________________
class Solution
{
    int getMiddle(Node head)
    {
         Node p = head;
         int len = 0;
         while(p!=null){
             
             len = len+1;
             p = p.next;
         }
         int mid = len/2;
         p = head;
         while(mid>0 && p!=null){
             mid = mid-1;
             
             p = p.next;
             
             
         }
        
         return p.data;
    }
}
__________________________________________________________________

class Solution {
    // static int Findfrequency(int ele,int[] nums){
    //     int count = 0;
    //     for(int i=0;i<nums.length;i++){
    //         if(nums[i]==ele){
    //             count = count + 1;
    //         }
    //     }
    //     // System.out.print(count);
    //     return count;
    // }
    public int majorityElement(int[] nums) {
        // int mostrepeated = 0;
        // int rept_val = 0;
        // int frequency;
        // for(int i=0;i<nums.length;i++){
        //     if(Findfrequency(nums[i],nums)>mostrepeated){
        //         mostrepeated = Findfrequency(nums[i],nums);
        //         rept_val = nums[i];
        //     }
        // }
        // System.out.print(rept_val);
        // return rept_val;
        int index=0;
        int count = 0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==nums[index]){
                count++;
            }else{
                count--;
            }
            if(count<0){
                index = i;
                count = 1;
            }
        }
        return nums[index];
    }
}
_________________________________________________________

class Solution {
    static int Findfrequency(int ele,int[] nums){
        int count = 0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==ele){
                count = count + 1;
            }
        }
        // System.out.print(count);
        return count;
    }
    public int majorityElement(int[] nums) {
        int mostrepeated = 0;
        int rept_val = 0;
        int frequency;
        for(int i=0;i<nums.length;i++){
            if(Findfrequency(nums[i],nums)>mostrepeated){
                mostrepeated = Findfrequency(nums[i],nums);
                rept_val = nums[i];
            }
        }
        // System.out.print(rept_val);
        return rept_val;
    }
}
_________________________________________________________
class Solution {
    public int getDecimalValue(ListNode head) {
        String binaryString="";
        while(head != null){
            binaryString = binaryString + Integer.toString(head.val);
            head = head.next;
        }
        int decimal=Integer.parseInt(binaryString,2);  
        return decimal;
    }
} 
   static boolean hasCycle(SinglyLinkedListNode head) {
        // boolean out = false;
        // ArrayList<Integer>  = new ArrayList<String>();
        int size = 0;
        
        // SinglyLinkedList a = new SinglyLinkedList();
        // SinglyLinkedList b = head;
        while(head != null){
            if(size >1000){
                return true;
            }
            
            // if(head.data ){
                
            // }
            // System.out.println(head.data);
            head = head.next;
            size++;
        }
        
        return false;

    }
______________________________________
class Solution {
    // public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    //     ListNode a = new ListNode();
    //     ListNode ans = a;
    //     int carr=0, sum;
    //     while(l1 != null || l2 != null){
    //         ListNode node = new ListNode();
    //         // ans = ans.next;
    //         if(carr != 0)
    //             node.val += carr;
    //         sum = l1.val+l2.val;
    //         if(sum>9){
    //             carr = sum/10;
    //             sum %= 10;
    //         }
    //         node.val += sum;
    //         // System.out.println(sum+" "+carr+"  "+ node.val);
    //         l1 = l1.next;
    //         l2 = l2.next;
    //         ans.next = node;
    //         ans = ans.next;
    //         // System.out.println(ans.next.val);
    //     }
    //     a=a.next;
    //     return(a);
    // }
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode dummyHead = new ListNode(0);
    ListNode p = l1, q = l2, curr = dummyHead;
    int carry = 0;
    while (p != null || q != null) {
        int x = (p != null) ? p.val : 0;
        int y = (q != null) ? q.val : 0;
        int sum = carry + x + y;
        carry = sum / 10;
        curr.next = new ListNode(sum % 10);
        curr = curr.next;
        if (p != null) p = p.next;
        if (q != null) q = q.next;
    }
    if (carry > 0) {
        curr.next = new ListNode(carry);
    }
    return dummyHead.next;
}
}
_______________________________________________________________________
class Solution {
    public List<List<Integer>> generate(int numRows) {
        
        List<List<Integer>> pascal = new ArrayList<>();
        
        pascal.add(new ArrayList<>());
        pascal.get(0).add(1);
        
        
        for (int row = 1; row < numRows; row++)
        {
            for (int col = 0; col < row+1; col++)
            {
                int left = (col == 0)  ? 0 : pascal.get(row-1).get(col-1);
                int right = (col == row) ? 0: pascal.get(row-1).get(col);
                
                if (col ==0)
                    pascal.add(new ArrayList<>());
                
                pascal.get(row).add(left+right);
            }
           
        }
        
        return pascal;
    }
}
______________________________________________
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        arr = []
        for i in range(numRows):
            b=[]
            b.append(1)
            for j in range(1, i):
                b.append(arr[i-1][j-1]+arr[i-1][j])
            if i>0:
                b.append(1)
            arr.append(b)
        return arr
________________________________________________________________________
class Solution {
    boolean hasPathSum = false;
    public boolean hasPathSum(TreeNode root, int targetSum) {
        findPath(root, new int[1], targetSum);
        return hasPathSum;
    }
    
    public void findPath(TreeNode root, int[] sum, int targetSum) {
        if(root == null)
            return;
        sum[0]+=root.val;
        if(root.left == null && root.right == null) {
            if(sum[0] == targetSum)
                hasPathSum = true;
        }
        findPath(root.left, sum, targetSum);
        findPath(root.right, sum, targetSum);
        sum[0]-=root.val;
    }
}
______________________________________________
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null){
            return 0;
        }else if(root.right==null){
            return 1+minDepth(root.left);
        }else if(root.left == null){
            return 1+minDepth(root.right);
        }
        else{
            return 1+min(minDepth(root.left),minDepth(root.right));
        }
    }
    static int min(int a, int b){
        if(a<b)
            return a;
        else
            return b;
    }
}
_________________________________________________________
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null)
            return 0;
        else
            return 1+max(maxDepth(root.left), maxDepth(root.right));
    }
    static int max(int a, int b){
        if(a>b)
            return a;
        else
            return b;
    }
    public boolean isBalanced(TreeNode root) {
        if(root == null){
            return true;
        }
        else if(Math.abs(maxDepth(root.left)-maxDepth(root.right))>1){
            return false;
            
        }else{
            return isBalanced(root.right) && isBalanced(root.left);
        }
        
    }
   
    
}
_______________________________________________________________________________
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return createBST(nums, 0, nums.length-1);
    }
    
    private TreeNode createBST(int[] nums, int left, int right) {
        if(right < left) {
            return null;
        }
        int mid = (right + left)/2;
        TreeNode leftTree = createBST(nums, left, mid-1);
        TreeNode rightTree = createBST(nums, mid+1, right);
        TreeNode node = new TreeNode(nums[mid], leftTree, rightTree);
        return node;
    }
}
______________________________________________________________________
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null)
            return 0;
        else
            return 1+max(maxDepth(root.left), maxDepth(root.right));
    }
    static int max(int a, int b){
        if(a>b)
            return a;
        else
            return b;
    }
    
}
_____________________________________________________________________
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return(check(root, root));
    }
    static boolean check(TreeNode p, TreeNode q){
        if(p == null && q == null)
            return true;
        if((p == null && q !=null) || (p != null && q == null))
            return false;
        else if(p.val != q.val) 
            return false;
        return check(p.left, q.right) && check(p.right, q.left);
    }
}
------------------------------------------------------------
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
            
        if (p == null && q == null) return true;
        if ((p != null && q == null)||(p == null && q != null)) return false;
        else if(p.val != q.val) return false;
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
             
    }
}
--------------------------------------------------------------------------------
check the code;
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
//         boolean x = true;
//         if (p != null && q!=null) {
//             if(p.val != q.val){
//                 x = false;
//             }
//             else if((p==null || q==null) && (p!=null || q != null) ){
//                 x = false;
//             }
//             else{
//                 x = isSameTree(p.left,q.left);
//             }
//             // x = isSameTree(p.left,q.left);
//             // x = isSameTree(p.left,q.right);
            
//         }
//         return x;
        boolean x=true;
        if(p==null && q==null){
            x = true;
        }
        else if((p==null || q==null) && (p!=null || q != null) ){
            x = false;
        }
        else if(p.val != q.val){
            x = false;
        }
        else if (p != null && q != null) {
            x = isSameTree(p.left,q.left);
            
            x = isSameTree(p.right,q.right);
        }
        return x;
        
     
    }
}
____________________________________________________________________________________________________________________
public class Tree { 
    static class Node {    
    int value; 
        Node left, right; 
          
        Node(int value){ 
            this.value = value; 
            left = null; 
            right = null; 
        } 
    } 
       
    public void insert(Node node, int value) {
        if (value < node.value) { if (node.left != null) { insert(node.left, value); } else { System.out.println(" Inserted " + value + " to left of " + node.value); node.left = new Node(value); } } else if (value > node.value) {
          if (node.right != null) {
            insert(node.right, value);
          } else {
            System.out.println("  Inserted " + value + " to right of "
                + node.value);
            node.right = new Node(value);
          }
        }
      }
     public void traverseInOrder(Node node) {
        if (node != null) {
            traverseInOrder(node.left);
            System.out.print(" " + node.value);
            traverseInOrder(node.right);
        }
     }
     
     public static void main(String args[]) 
    { 
    Tree tree = new Tree();
                Node root = new Node(5);
                System.out.println("Binary Tree Example");
                System.out.println("Building tree with root value " + root.value);
                tree.insert(root, 2);
                tree.insert(root, 4);
                tree.insert(root, 8);
                tree.insert(root, 6);
                tree.insert(root, 7);
                tree.insert(root, 3);
                tree.insert(root, 9);
                System.out.println("Traversing tree in order");
                tree.traverseLevelOrder();
                
              }
}
  
____________________________________________________________________________________________________________
public class Solution {
    public int climbStairs(int n) {
        int memo[] = new int[n + 1];
        return climb_Stairs(0, n, memo);
    }
    public int climb_Stairs(int i, int n, int memo[]) {
        if (i > n) {
            return 0;
        }
        if (i == n) {
            return 1;
        }
        if (memo[i] > 0) {
            return memo[i];
        }
        memo[i] = climb_Stairs(i + 1, n, memo) + climb_Stairs(i + 2, n, memo);
        return memo[i];
    }
}
---------------------------------------------------------------
public class Solution {
    public int climbStairs(int n) {
        return climb_Stairs(0, n);
    }
    public int climb_Stairs(int i, int n) {
        if (i > n) {
            return 0;
        }
        if (i == n) {
            return 1;
        }
        return climb_Stairs(i + 1, n) + climb_Stairs(i + 2, n);
    }
}
################################################
class Solution {
    public int arrangeCoins(int n) {
        int rows_full = 0;
 
        int i = 1;
        while(i<=n){
            n = n - i;
            i++;
            rows_full++;
            
            
        }
        return rows_full;
    }
}
###########################################################
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode r = new ListNode();
        ListNode rev = r, p=head, q;
        while(p!=null){
            ListNode t = new ListNode();
            t.val=p.val;
            t.next = rev.next;
            rev.next = t;
            p = p.next;
        }
        rev = rev.next;
        while(rev!=null) {
            if(rev.val !=head.val)
                 return (false);
            head = head.next;
            rev = rev.next;
        }
        return (true);
    }
}
#################################################
// class Solution {
//     ListNode pleft;
//     public boolean isPalindrome(ListNode head) {
//         pleft = head;
//         boolean res= isPalindromeHelper(head);
//         return res;
//     }
    
//     public boolean isPalindromeHelper(ListNode right){
//         if(right==null){
//             return true;
//         }
        
//         boolean rres = isPalindromeHelper(right.next);
//         if(rres==false){
//             return false;
//         }else if(pleft.val != right.val){
//             return false;
//         }else{
//             pleft = pleft.next;
//             return true;
//         }
//     }
//  }


#####################################################
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    
        
        ListNode dummy = new ListNode();
        ListNode currentl1 = l1;
        ListNode currentl2 = l2;
        ListNode megedLinkedList = dummy;
        while(currentl1 != null || currentl2 != null){
            
            if(currentl1 == null ){
               megedLinkedList.next = currentl2;
                break;
            }
            
            if(currentl2 == null){
                megedLinkedList.next = currentl1;
                break;
            }
            
        
            if(currentl1.val  >  currentl2.val){
                megedLinkedList.next =  currentl2;
                currentl2 = currentl2.next;
            }else{
                megedLinkedList.next =  currentl1;
                currentl1 = currentl1.next;
            }
            
            megedLinkedList = megedLinkedList.next;
        }
        
      return dummy.next;
        
    }
}
###########################################################
def solve(s):
    
    t = ""
    t = t + s[0].capitalize()
    for i in range(1,len(s)):
        if(s[i-1]==" "):
            
            t = t + s[i].upper()
        else:
            t = t +s[i]
        
        
        
        
    
    return t
####################################
def merge_the_tools(string, k):
    # your code goes here
    s = []
    for i in range(0,len(string),k):
        s.append(string[i:k])
        k = k+k
    
    for i in s:
        o = ""
        for j in i:
            if j not in o:
                o = o+j
        print(o) 
        

if __name__ == '__main__':
    string, k = input(), int(input())
    merge_the_tools(string, k)
###################################################
perfect squares sum to a given num:
class Solution:
    def numSquares(self, n: int) -> int:
        no_perfect = 0
        squares = []
        for i in range(1,int(n**0.5)+1):
            squares.append(i**2)
        v = []
        
        def printAllSubsetsRec(arr, n, v, Sum):

            
            if (Sum == 0):
                return len(v)

            if (Sum < 0):
                return sys.maxsize

            
            if (n == 0):
                return sys.maxsize

            
            x = printAllSubsetsRec(arr, n - 1, v, Sum)

            
            v.append(arr[n - 1])
            y = printAllSubsetsRec(arr, n, v,
                                   Sum - arr[n - 1])
            v.pop(len(v) - 1)

            return min(x, y)

        
        def printAllSubsets(arr, n, Sum):

            v = []
            return printAllSubsetsRec(arr, n, v, Sum)

        
        arr = squares
        Sum = n
        m = len(arr)

        return printAllSubsets(arr, m, Sum)
        

######################

    def reverseWords(self, s: str) -> str:
        out = ""
        arr = s.split()
        rev_arr = arr[::-1]
        for i in rev_arr: 
            out += i+" "  
    
   
            
            
        return out[:len(out)-1]
##############################################
--> next permutation:
class Solution:
    def nextPermutation(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        #>right
        i = len(nums)-1
        while i-1>=0 and nums[i-1]>=nums[i]:
            i -=1
        #>left
        if i-1>=0:
            j = i
            while j<len(nums) and nums[j]>nums[i-1]:
                j +=1
            #swap the min-max number
            nums[i-1],nums[j-1] = nums[j-1],nums[i-1]
        m = i
        n = len(nums)-1
        while m < n:
            nums[m],nums[n] = nums[n],nums[m]
            m +=1
            n -=1
###########################################################
check this-->

if __name__ == '__main__':
    x = int(raw_input())
    y = int(raw_input())
    z = int(raw_input())
    n = int(raw_input())
    out = []
    for i in range(x+1):
        if(i<=y):
            for j in range(y+1):
                if(j<=z):
                    arr=[]
                    for k in range(z+1):
                        
                        if(i+j+k !=n):
                            out.append([i,j,k])
    print(out)
               
##################
crct ans-->

if __name__ == '__main__':
    x = int(raw_input())
    y = int(raw_input())
    z = int(raw_input())
    n = int(raw_input())
    out = []
    for i in range(x+1):
        for j in range(y+1):
                for k in range(z+1):
                        
                        if(i+j+k !=n):
                            out.append([i,j,k])
    print(out)
                            
                            
                
##############################
if __name__ == '__main__':
    stds = []
    mrks = []
    mrks_without_dup = []
    out_arr = []
    
    for _ in range(int(input())):
        name = input()
        score = float(input())
        stds.append([name,score])
    
    l = len(stds)
    for i in stds:
        mrks.append(i[1])
    mrks.sort()
    for i in mrks:
        if(i not in mrks_without_dup):
            mrks_without_dup.append(i)
    second_lowest = mrks_without_dup[1]
    
    for i in stds:
        if(i[1]==second_lowest):
            out_arr .append(i[0])
    out_arr.sort()
    for j in out_arr:
        print(j)
######################################
T = int(input())
while(T):
  a = input().split()
  n = int(a[0])
  k = int(a[1])
  sum_ken = 0
  sum_amar = 0
  b = input().split()
  c = input().split()
  
  b = [int(i) for i in b]
  c = [int(i) for i in c]
  b.sort()
  c.sort()
  for i in range(k,0,-1):
    sum_ken = sum_ken + b[i]
  for i in range(k,0,-1):
    sum_amar = sum_amar + c[i]
  if(sum_ken > sum_amar):
    print("WIN")
  else:
    print("LOSE")
  T = T -1
#############################################
if __name__ == '__main__':
    stds = []
    mrks = []
    mrks_without_dup = []
    out_arr = []
    
    for _ in range(int(input())):
        name = input()
        score = float(input())
        stds.append([name,score])
    
    l = len(stds)
    for i in stds:
        mrks.append(i[1])
    mrks.sort()
    for i in mrks:
        if(i not in mrks_without_dup):
            mrks_without_dup.append(i)
    second_lowest = mrks_without_dup[1]
    
    for i in stds:
        if(i[1]==second_lowest):
            out_arr .append(i[0])
    out_arr.sort()
    for j in out_arr:
        print(j)
    
#######################################################
#!/bin/python3

import math
import os
import random
import re
import sys

#
# Complete the 'climbingLeaderboard' function below.
#
# The function is expected to return an INTEGER_ARRAY.
# The function accepts following parameters:
#  1. INTEGER_ARRAY ranked
#  2. INTEGER_ARRAY player
#

def climbingLeaderboard(ranked, player):
    # Write your code here
    ans = []
    for i in player:
        ranked.append(i)
        res = []
        [res.append(x) for x in ranked if x not in res]
        res.sort(reverse=True)
        ans.append(res.index(i)+1)
    return ans
if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    ranked_count = int(input().strip())

    ranked = list(map(int, input().rstrip().split()))

    player_count = int(input().strip())

    player = list(map(int, input().rstrip().split()))

    result = climbingLeaderboard(ranked, player)

    fptr.write('\n'.join(map(str, result)))
    fptr.write('\n')

    fptr.close()

###################################
li1 = ['A','B','C','D']
li2 = ['B','C']
uncomman_elements = list(set(li1) - set(li2)) + list(set(li2) - set(li1))
print(uncomman_elements)
for i in uncomman_elements:
    out1 = 0
    out2 = 0
    for j in str(ord(i)):
        
        out1 = out1 + int(j)
    for k in str(out1):
        out2 = out2 + int(k)
    print(out1)
    print(out2)
    
###############################################
i1 = 3521
i2 = 2452
i3 = 1352

# l_th = 0
# l_h =0
# l_t = 0
# l_u = 0
# s_th = 9
# s_h = 9
# s_t = 9
# s_u = 9

# print(i1%10)
# print(int((i1/10)%10))
# print(int(i1/100)%10)
# print(int(i1/1000))



if (i1%10 >= i2%10) and (i1%10 >= i3%10):
   l_u = i1%10
elif (i2%10 >= i1%10) and (i2%10 >= i3%10):
   l_u = i2%10
else:
   l_u = i3%10
   
   
if (int((i1/10)%10) >= int((i2/10)%10)) and (int((i1/10)%10) >= int((i3/10)%10)):
   l_t = int((i1/10)%10)
elif (int((i2/10)%10) >= int((i1/10)%10)) and (int((i2/10)%10) >= int((i3/10)%10)):
   l_t = int((i2/10)%10)
else:
    l_t = int((i3/10)%10)
    
if (int((i1/10)%10) >= int((i2/10)%10)) and (int((i1/10)%10) >= int((i3/10)%10)):
   l_t = int((i1/10)%10)
elif (int((i2/10)%10) >= int((i1/10)%10)) and (int((i2/10)%10) >= int((i3/10)%10)):
   l_t = int((i2/10)%10)
else:
    l_t = int((i3/10)%10)
   


##############################################
# Enter your code here. Read input from STDIN. Print output to STDOUT\
arr=input().split()
n=int(arr[0])
m=int(arr[1])
# first half
for i in range(int(n/2)):
    for j in range(int(n/2)-i):
        print("---", end="")
    for k in range(1+i*2):
        print(".|.", end="")
    for j in range(int(n/2)-i):
        print("---", end="")
    print()
    
# welcome
for i in range(int((m-7)/2)):
    print("-", end="")
print("WELCOME", end="")
for i in range(int((m-7)/2)):
    print("-", end="")
print()

# second half
for i in range(int(n/2)-1, -1, -1):
    for j in range(int(n/2)-i):
        print("---", end="")
    for k in range(1+i*2):
        print(".|.", end="")
    for j in range(int(n/2)-i):
        print("---", end="")
    print()
##########################################################
def print_formatted(number):
    # your code goes here
    for i in range(1,number+1):
        decimal = i
        
        # print(decimal,end=" ")
        # print("  ",end="")
        # print(decimal,end=" ")
        # print()
        # Python program to convert decimal into other number systems
        

        
        binary = bin(decimal)
        octal = oct(decimal)
        hexa = hex(decimal)
         
        # s=""
        # while(i):
        #     s=s+str(int(i%2))
        #     i=int(i/2)
        # binary = (s[::-1])
        print(decimal,end="   ")
        print(str(octal[2:]),end="   ")
        print(str(hexa[2:]).upper(),end = "   ")
        print(str(binary[2:]),end="   ")
        print()
        

if __name__ == '__main__':
    n = int(input())
    print_formatted(n)
###########################################################
def print_formatted(number):
    # your code goes here
    w = len(str(bin(number)).replace('0b',''))

    for i in range(1, number+1):
        b = bin(int(i)).replace('0b','').rjust(w, ' ')
        o = oct(int(i)).replace('0o','', 1).rjust(w, ' ')
        h = hex(int(i)).replace('0x','').upper().rjust(w, ' ')
        j = str(i).rjust(w, ' ')
        print(j, o, h, b)
    
        

if __name__ == '__main__':
#############################################################